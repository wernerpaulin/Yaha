(*@PROPERTIES_EX@
TYPE: POU
LOCALE: 0
IEC_LANGUAGE: ST
PLC_TYPE: independent
PROC_TYPE: independent
GROUP: TIME_DATE
*)
(*@KEY@:DESCRIPTION*)
version 1.10	7. oct. 2008
programmer 	hugo
tested by	oscat

this is a decoder for a DCF77 signal.
the decoder decodes the DCF77 signal and checks for a valid Date_Time.
since the dcf77 signal is only secured with a simple parity the decoder waits for two consecutive valid transmissions before it sets the output signals.
given a valid reception by the receiver the decoder can take up to 3 minutes to start its clocks the first time.
after a valid signal is detected the error output goes low and dignals a valid dcf signal from the receiver.
a tp is only valid for one program cycle to allow for external rtc setting.
after a valid signal is detected two independent internal clocks are started (RTC and RTC1), the seconds  of these clocks are generated by software since the dcf signal is only valid for minutes.
rtc is always utc ( world time) and rtc1 can be set to any time zone by setting the time_zone_offset and enabling dst for automatic summertime.
a sync output signals the the rtc and rtc1 are in sync with the dcf77 signal, if the dcf77 signal is lost for more then the sync time the sync output goes low
but the rtc and rtc1 outputs keep running based on software timing until a valid dcf77 signal is received again and triggers the clock.
in addition a millisecond output gives further resolutionof the clocks.
a dst output shows if daylight saving time is enables and the weekday output shows which day of week currently is ( 1= monday ... 7= sunday).
(*@KEY@:END_DESCRIPTION*)
FUNCTION_BLOCK DCF77

(*Group:Default*)


VAR_INPUT
	REC :	BOOL;
	SET :	BOOL;
	SDT :	UDINT;
	DSI :	BOOL;
	SYNC_TIMEOUT :	TIME := t#2m;
	TIME_OFFSET :	INT := 1;
	DST_EN :	BOOL := TRUE;
END_VAR


VAR_OUTPUT
	TP :	BOOL;
	DS :	BOOL;
	WDAY :	INT;
	ERROR :	BOOL := TRUE;
	RTC :	UDINT;
	RTC1 :	UDINT;
	MSEC :	INT;
	SYNC :	BOOL;
END_VAR


VAR
	MEZ :	UDINT;
	UTC :	UDINT;
	state :	INT;
	edge :	BOOL;
	tx :	TIME;
	ty :	TIME;
	last :	TIME;
	bits :	oscat_dcf77_bits;
	cnt :	INT;
	i :	INT;
	old_time :	UDINT;
	minute :	INT;
	hour :	INT;
	day :	INT;
	month :	INT;
	year :	INT;
	last_sync :	TIME;
	t1 :	TIME;
	tz :	TIME;
	init :	BOOL;
	word_temp :	WORD;
	bool_temp :	BOOL;
	T_PLC_MS :	T_PLC_MS;
END_VAR


(*@KEY@: WORKSHEET
NAME: DCF77
IEC_LANGUAGE: ST
*)
(* if tp was set it should only be active for 1 cycle *)
TP := FALSE;

(* read system time *)
T_PLC_MS();
t1:= UDINT_TO_TIME(T_PLC_MS.T_PLC_MS);
tx := t1 - last;

IF rec XOR edge THEN
	edge := rec;
	IF NOT rec AND tx > t#1700ms AND tx < t#2000ms THEN
		(* start condition reached *)
		state := 0;
		tp := NOT error;
	ELSIF NOT rec AND tx > t#700ms AND tx < t#1000ms THEN
		(* second switch detected *)
		IF state < 58 THEN state := state +1; ELSE state := 0; END_IF;
	ELSIF rec AND tx  < t#120ms THEN
		(* bit 0 detected  *)
		bits[state] := FALSE;
	ELSIF rec AND tx > t#120ms AND tx < t#250ms THEN
		(* bit 1 detected *)
		bits[state] := TRUE;
	ELSE
		(* error condition received signal is not valid *)
		error := TRUE;
		state := 0;
	END_IF;
	last := last + tx;
	IF rec AND state = 58 THEN
		error := FALSE;

		(* decode the bits and check for possible errors *)
		IF bits[0] OR NOT (bits[17] XOR bits[18]) OR NOT bits[20] THEN error := TRUE; END_IF;
		(* decode minute *)
        word_temp := WORD#0;

        bool_temp:=bits[21];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,0);    (* word_temp.X0 := bits[21]; *)
        bool_temp:=bits[22];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,1);    (* word_temp.X1 := bits[22]; *)
        bool_temp:=bits[23];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,2);    (* word_temp.X2 := bits[23]; *)
        bool_temp:=bits[24];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,3);    (* word_temp.X3 := bits[24]; *)

        minute := WORD_TO_INT(word_temp);
		IF bits[25] THEN minute := minute +10; END_IF;
		IF bits[26] THEN minute := minute +20; END_IF;
		IF bits[27] THEN minute := minute +40; END_IF;
		IF minute > 59 OR (bits[21] XOR bits[22] XOR bits[23] XOR bits[24] XOR bits[25] XOR bits[26] XOR bits[27] XOR bits[28]) THEN error := TRUE; END_IF;

		(* decode hour *)
        word_temp := WORD#0;

        bool_temp:=bits[29];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,0);    (* word_temp.X0 := bits[29]; *)
        bool_temp:=bits[30];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,1);    (* word_temp.X1 := bits[30]; *)
        bool_temp:=bits[31];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,2);    (* word_temp.X2 := bits[31]; *)
        bool_temp:=bits[32];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,3);    (* word_temp.X3 := bits[32]; *)

        hour := WORD_TO_INT(word_temp);
		IF bits[33] THEN hour := hour +10; END_IF;
		IF bits[34] THEN hour := hour +20; END_IF;
		IF hour > 23 OR (bits[29] XOR bits[30] XOR bits[31] XOR bits[32] XOR bits[33] XOR bits[34] XOR bits[35]) THEN error := TRUE; END_IF;

		(* decode day of month *)
        word_temp := WORD#0;

        bool_temp:=bits[36];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,0);    (* word_temp.X0 := bits[36]; *)
        bool_temp:=bits[37];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,1);    (* word_temp.X1 := bits[37]; *)
        bool_temp:=bits[38];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,2);    (* word_temp.X2 := bits[38]; *)
        bool_temp:=bits[39];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,3);    (* word_temp.X3 := bits[39]; *)

        day := WORD_TO_INT(word_temp);
		IF bits[40] THEN day := day + 10; END_IF;
		IF bits[41] THEN day := day + 20; END_IF;
		IF day > 31 THEN error := TRUE; END_IF;

		(* decode day of week *)
        word_temp := WORD#0;

        bool_temp:=bits[42];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,0);    (* word_temp.X0 := bits[42]; *)
        bool_temp:=bits[43];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,1);    (* word_temp.X1 := bits[43]; *)
        bool_temp:=bits[44];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,2);    (* word_temp.X2 := bits[44]; *)

        wday := WORD_TO_INT(word_temp);
		IF wday > 7 OR wday < 1 THEN error := TRUE; END_IF;

		(* decode month *)
        word_temp := WORD#0;

        bool_temp:=bits[45];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,0);    (* word_temp.X0 := bits[45]; *)
        bool_temp:=bits[46];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,1);    (* word_temp.X1 := bits[46]; *)
        bool_temp:=bits[47];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,2);    (* word_temp.X2 := bits[47]; *)
        bool_temp:=bits[48];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,3);    (* word_temp.X3 := bits[48]; *)

        month := WORD_TO_INT(word_temp);
		IF bits[49] THEN month := month +10; END_IF;
		IF month > 12 THEN error := TRUE; END_IF;

		(* decode year *)
        word_temp := WORD#0;

        bool_temp:=bits[50];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,0);    (* word_temp.X0 := bits[50]; *)
        bool_temp:=bits[51];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,1);    (* word_temp.X1 := bits[51]; *)
        bool_temp:=bits[52];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,2);    (* word_temp.X2 := bits[52]; *)
        bool_temp:=bits[53];
        word_temp:=BIT_LOAD_W(word_temp,bool_temp,3);    (* word_temp.X3 := bits[53]; *)

        year := WORD_TO_INT(word_temp);
		IF bits[54] THEN year := year + 10; END_IF;
		IF bits[55] THEN year := year + 20; END_IF;
		IF bits[56] THEN year := year + 40; END_IF;
		IF bits[57] THEN year := year + 80; END_IF;

		(* check parity for bits 36 to 58 *)
		cnt := 0;
		FOR i := 36 TO 58 DO IF bits[i] THEN cnt := cnt + 1; END_IF; END_FOR;
		IF NOT even(INT_TO_DINT(cnt)) THEN error := TRUE; END_IF;

		(* time must be valid for two cycles to clear error flag *)
		IF NOT error THEN
			(* set outputs *)
			old_time := mez;
			IF year >= 70 THEN year := year + 1900; ELSE year := year + 2000; END_IF;
			mez := set_DT(year,month,day,hour,minute,0);
			DS := bits[17];
			IF DS THEN
				UTC := mez - UDINT#7200;
			ELSE
				UTC := mez - UDINT#3600;
			END_IF;

			(* set trigger signal only if the receiver has received 2 successive minutes *)
			IF mez <> old_time + TIME_TO_UDINT(t#1m) THEN error := TRUE ; END_IF;
		END_IF;
	END_IF;
END_IF;

(* this portion implements a free running clock which is triggered by the dcf77 signal *)
tz := UDINT_TO_TIME(_INT_TO_UDINT(ABS(time_offset))* UDINT#3600000);

(* input sdt is copied to utc at first power up *)
IF NOT init OR SET THEN
	init := TRUE;
	utc := sdt;
	tp := TRUE;
	DS := DSI;
END_IF;

IF tp THEN
	rtc := utc;
	IF DS AND dst_en THEN
		IF time_offset < 0 THEN
        	rtc1 := rtc - TIME_TO_UDINT(tz + t#1h);
        ELSE 
            rtc1 := rtc + TIME_TO_UDINT(tz + t#1h);
        END_IF;
	ELSE
		IF time_offset < 0 THEN
            rtc1 := rtc - TIME_TO_UDINT(tz);
        ELSE
            rtc1 := rtc + TIME_TO_UDINT(tz);
        END_IF;
	END_IF;
	sync := TRUE;
	last_sync := last;
	ty := last;
ELSIF rtc > UDINT#0 AND T1 - ty >= t#1s THEN
	rtc := rtc + TIME_TO_UDINT(t#1s);
	rtc1 := rtc1 + TIME_TO_UDINT(t#1s);
	ty := ty + t#1s;
	sync := ty - last_sync < sync_timeout AND last_sync > t#0s;
	wday := DAY_OF_WEEK(DT_TO_DATE(rtc1));
	DS := dst_en AND DST(utc);
END_IF;
msec := TIME_TO_INT(t1 - ty);

(* decode information
bits		content
0			Bitwert immer 0
1 bis 14	reserviert für Betriebsinformationen (nicht für DCF77-Nutzer bestimmt)
15			Rufbit für Alarmierung der PTB-Mitarbeiter
			(bis Mai 2003: Bitwert = 0 falls normale Antenne in Verwendung; 1 = Backupantenne)
16			Bitwert = 1 falls ein Wechsel von MEZ nach MESZ oder umgekehrt bevorsteht; Dauer der Anzeige: 1 Stunde
17 + 18	gültige Zeit = MEZ, falls Bit 17=0 und Bit 18=1
			gültige Zeit = MESZ, falls Bit 17=1 und Bit 18=0
19			Bitwert = 1 falls innerhalb den nächsten 59 Minuten eine Schaltsekunde angeordnet ist. Beim Einfügen einer Schaltsekunde wird anstelle der 59. die 60. Sekundenmarke weggelassen und in der 58. erfolgt ausnahmsweise ein Trägerabfall.
20			Startbit für Zeitinformation (immer 1)
21 - 27		1, 2, 4, 8, 10, 20, 40 Minuten (bitweise Addition)
28			Prüfbit (gerade Parität) für die Bits 21-27
29 - 34		1, 2, 4, 8, 10, 20 Stunden (bitweise Addition)
35			Prüfbit (gerade Parität) für die Bits 29-34
36 - 41		Tagesnummer im aktuellen Monat: 1, 2, 4, 8, 10, 20 (bitweise Addition)
42 - 44		Tagesnummer in der aktuellen Woche: 1, 2, 4 (bitweise Addition)
45 - 49		Monatsnummer: 1, 2, 4, 8, 10 (bitweise Addition)
50 - 57		Jahr (zweistellig): 1, 2, 4, 8, 10, 20, 40, 80 (bitweise Addition)
58			Prüfbit (gerade Parität) füR die Bits 36-57

*)
(* revision history

hm 2.feb 2007		rev 1.1
	change wday and dst outputs when there is no dcf reception

hm	26.feb 2007		rev 1.2
	changed statements where t#1h would be substracted from DT.
	under certain conditions the compiler would crash translating this statement

hm	17. sep 2007	rev 1.3
	replaced time() with T_PLC_MS() for compatibility reasons

hm	24. oct 2007		rev 1.4
	changed dst calculation because function dst was upgraded no error in DCF77 only a change in DST

hm	12. nov 2007		rev 1.5
	changed time_offset from time to integer to allow for negative offset time zones

hm	8. dec 2007		rev 1.6
	corrected an error in time_zone calculation

hm 23. jan 2008		rev 1.7
	added sdt input which is used to initialize rtc and rtc1 during first cycle.

hm 16. mar 2008		rev 1.8
	changed output weekday to wday and dst to ds for compatibility reasons

hm	19. apr. 2008	rev 1.9
	added input dsi to allow to set daylight savings time when SDT is TRUE.
	added asynchronous SET input

hm	7. oct. 2008	rev 1.10
	changed function weekday to day_of_week

*)
(*@KEY@: END_WORKSHEET *)
END_FUNCTION_BLOCK
